Computing Neural Network Gradients Kevin Clark 1 Introduction The purpose of these notes is to demonstrate how to quickly compute neural network gradients in a completely vectorized way. It is complementary to the last part of lecture 3 in CS224n 2019 which goes over the same material. 2 Vectorized Gradients While it is a good exercise to compute the gradient of a neural network with re spect to a single parameter e.g. a single element in a weight matrix in practice this tends to be quite slow. Instead it is more eﬃcient to keep everything in ma trix vector form. The basic building block of vectorized gradients is the Jacobian Matrix. Suppose we have a function f Rn Rm that maps a vector of length n to a vector of length m f x f1 x1 ... xn f2 x1 ... xn ... fm x1 ... xn . Then its Jacobian is the following m n matrix f x f1 x1 . . . f1 xn . . . ... . . . fm x1 . . . fm xn That is f x ij fi xj which is just a standard non vector derivative . The Jacobian matrix will be useful for us because we can apply the chain rule to a vector valued function just by multiplying Jacobians. As a little illustration of this suppose we have a function f x f1 x f2 x taking a scalar to a vector of size 2 and a function g y g1 y1 y2 g2 y1 y2 taking a vector of size two to a vector of size two. Now let s compose them to get g x g1 f1 x f2 x g2 f1 x f2 x . Using the regular chain rule we can compute the derivative of g as the Jacobian g x xg1 f1 x f2 x xg2 f1 x f2 x g1 f1 f1 x g1 f2 f2 x g2 f1 f1 x g2 f2 f2 x 1And we see this is the same as multiplying the two Jacobians g x g f f x g1 f1 g1 f2 g2 f1 g2 f2 f1 x f2 x 3 Useful Identities This section will now go over how to compute the Jacobian for several simple functions. It will provide some useful identities you can apply when taking neu ral network gradients. 1 Matrix times column vector with respect to the column vector z W x what is z x Suppose W Rn m. Then we can think of z as a function of x taking an m dimensional vector to an n dimensional vector. So its Jacobian will be n m. Note that zi m X k 1 Wikxk So an entry z x ij of the Jacobian will be z x ij zi xj xj m X k 1 Wikxk m X k 1 Wik xj xk Wij because xj xk 1 if k j and 0 if otherwise. So we see that z x W 2 Row vector times matrix with respect to the row vector z xW what is z x A computation similar to 1 shows that z x W T . 3 A vector with itself z x what is z x We have zi xi. So z x ij zi xj xj xi 1 if i j 0 if otherwise So we see that the Jacobian z x is a diagonal matrix where the entry at i i is 1. This is just the identity matrix z x I . When applying the chain 2rule this term will disappear because a matrix or vector multiplied by the identity matrix does not change. 4 An elementwise function applied a vector z f x what is z x Since f is being applied elementwise we have zi f xi . So z x ij zi xj xj f xi f xi if i j 0 if otherwise So we see that the Jacobian z x is a diagonal matrix where the entry at i i is the derivative of f applied to xi. We can write this as z x diag f x . Since multiplication by a diagonal matrix is the same as doing elementwise multiplication by the diagonal we could also write f x when applying the chain rule. 5 Matrix times column vector with respect to the matrix z W x δ J z what is J W J z z W δ z W This is a bit more complicated than the other identities. The reason for in cluding J z in the above problem formulation will become clear in a moment. First suppose we have a loss function J a scalar and are computing its gradient with respect to a matrix W Rn m. Then we could think of J as a function of W taking nm inputs the entries of W to a single output J . This means the Jacobian J W would be a 1 nm vector. But in practice this is not a very useful way of arranging the gradient. It would be much nicer if the derivatives were in a n m matrix like this J W J W11 . . . J W1m . . . ... . . . J Wn1 . . . J Wnm Since this matrix has the same shape as W we could just subtract it times the learning rate from W when doing gradient descent. So in a slight abuse of notation let s ﬁnd this matrix as J W instead. This way of arranging the gradients becomes complicated when computing z W . Unlike J z is a vector. So if we are trying to rearrange the gradients like with J W z W would be an n m n tensor Luckily we can avoid the issue by taking the gradient with respect to a single weight Wij instead. 3z Wij is just a vector which is much easier to deal with. We have zk m X l 1 Wklxl zk Wij m X l 1 xl Wij Wkl Note that Wij Wkl 1 if i k and j l and 0 if otherwise. So if k i everything in the sum is zero and the gradient is zero. Otherwise the only nonzero element of the sum is when l j so we just get xj. Thus we ﬁnd zk Wij xj if k i and 0 if otherwise. Another way of writing this is z Wij 0 . . . 0 xj 0 . . . 0 ith element Now let s compute J Wij J Wij J z z Wij δ z Wij m X k 1 δk zk Wij δixj the only nonzero term in the sum is δi zi Wij . To get J W we want a ma trix where entry i j is δixj. This matrix is equal to the outer product J W δT xT 6 Row vector time matrix with respect to the matrix z xW δ J z what is J W δ z W A similar computation to 5 shows that J W xT δ . 7 Cross entropy loss with respect to logits ˆ y softmax θ J CE y ˆ y what is J θ The gradient is J θ ˆ y y or ˆ y y T if y is a column vector . 4These identities will be enough to let you quickly compute the gradients for many neural networks. However it s important to know how to compute Jacobians for other functions as well in case they show up. Some examples if you want practice dot product of two vectors elementwise product of two vectors 2 norm of a vector. Feel free to use these identities in the assignments. One option is just to memorize them. Another option is to ﬁgure them out by looking at the dimensions. For example only one ordering orientation of δ and x will produce the correct shape for J W assuming W is not square . 4 Gradient Layout Jacobean formulation is great for applying the chain rule you just have to mul tiply the Jacobians. However when doing SGD it s more convenient to follow the convention the shape of the gradient equals the shape of the parameter as we did when computing J W . That way subtracting the gradient times the learning rate from the parameters is easy. We expect answers to homework questions to follow this convention. Therefore if you compute the gradient of a column vector using Jacobian formulation you should take the transpose when reporting your ﬁnal answer so the gradient is a column vector. Another option is to always follow the convention. In this case the identities may not work but you can still ﬁgure out the answer by making sure the dimensions of your derivatives match up. Up to you which of these options you choose 5 Example 1 Layer Neural Network This section provides an example of computing the gradients of a full neural network. In particular we are going to compute the gradients of a one layer neural network trained with cross entropy loss. The forward pass of the model is as follows x input z W x b1 h ReLU z θ Uh b2 ˆ y softmax θ J CE y ˆ y It helps to break up the model into the simplest parts possible so note that we deﬁned z and θ to split up the activation functions from the linear trans formations in the network s layers. The dimensions of the model s parameters are x RDx 1 b1 RDh 1 W RDh Dx b2 RNc 1 U RNc Dh where Dx is the size of our input Dh is the size of our hidden layer and Nc is the number of classes. 5In this example we will compute all of the network s gradients J U J b2 J W J b1 J x To start with recall that ReLU x max x 0 . This means ReLU x 1 if x 0 0 if otherwise sgn ReLU x where sgn is the signum function. Note that we are able to write the derivative of the activation in terms of the activation itself. Now let s write out the chain rule for J U and J b2 J U J ˆ y ˆ y θ θ U J b2 J ˆ y ˆ y θ θ b2 Notice that J ˆ y ˆ y θ J θ is present in both gradients. This makes the math a bit cumbersome. Even worse if we re implementing the model without automatic diﬀerentiation computing J θ twice will be ineﬃcient. So it will help us to deﬁne some variables to represent the intermediate derivatives δ1 J θ δ2 J z These can be thought as the error signals passed down to θ and z when doing backpropagation. We can compute them as follows δ1 J θ ˆ y y T this is just identity 7 δ2 J z J θ θ h h z using the chain rule δ1 θ h h z substituting in δ1 δ1 U h z using identity 1 δ1 U ReLU z using identity 4 δ1 U sgn h we computed this earlier A good way of checking our work is by looking at the dimensions of the Jaco bians J z δ1 U sgn h 1 Dh 1 Nc Nc Dh Dh 6We see that the dimensions of all the terms in the gradient match up i.e. the number of columns in a term equals the number of rows in the next term . This will always be the case if we computed our gradients correctly. Now we can use the error terms to compute our gradients. Note that we trans pose out answers when computing the gradients for column vectors terms to follow the shape convention. J U J θ θ U δ1 θ U δT 1 hT using identity 5 J b2 J θ θ b2 δ1 θ b2 δT 1 using identity 3 and transposing J W J θ z W δ2 z W δT 2 xT using identity 5 J b1 J θ z b1 δ2 z b1 δT 2 using identity 3 and transposing J x J θ z x δ2W T using identity 1 and transposing 7